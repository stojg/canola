{
  "version": 3,
  "sources": ["/Users/stojg/Sites/canola/src/ui/stats-widget.ts"],
  "sourcesContent": ["import type REGL from 'regl'\nimport { queryTimerExt } from '../lib/cap'\n\nconst getReadableFileSizeString = (fileSizeInBytes: number) => {\n  let i = -1\n  const byteUnits = [' kB', ' MB', ' GB', ' TB', 'PB', 'EB', 'ZB', 'YB']\n  do {\n    fileSizeInBytes = fileSizeInBytes / 1024\n    i++\n  } while (fileSizeInBytes > 1024)\n\n  return Math.max(fileSizeInBytes, 0.1).toFixed(1) + byteUnits[i]\n}\n\nexport function createStatsWidget(drawCalls: [REGL.DrawCommand, string][], regl: REGL.Regl): { update: (deltaTime: number) => void } {\n  const nullOp = { update: (dt: number) => {} }\n\n  // the widget keeps track of the previous values of gpuTime,\n  // in order to compute the frame time.\n  const prevGpuTimes: number[] = []\n  const prevCpuTimes: number[] = []\n  let i\n  for (i = 0; i < drawCalls.length; i++) {\n    prevGpuTimes[i] = 0\n    prevCpuTimes[i] = 0\n  }\n\n  // we update the widget every second, we need to keep track of the time:\n  let totalTime = 1.1\n\n  // we show the average frametime to the user.\n  const N = 50\n  const totalGpuFrameTime: number[] = []\n  const totalCpuFrameTime: number[] = []\n  let frameTimeCount = 0\n  const avgGpuFrameTime: number[] = []\n  const avgCpuFrameTime: number[] = []\n  for (i = 0; i < drawCalls.length; ++i) {\n    totalGpuFrameTime[i] = 0.0\n    avgGpuFrameTime[i] = 0.0\n    totalCpuFrameTime[i] = 0.0\n    avgCpuFrameTime[i] = 0.0\n  }\n\n  // the widget is contained in a <div>\n  const container = document.createElement('div')\n  container.style.cssText = 'position:fixed;top:5px;left:5px;opacity:0.8;z-index:10000;'\n  const pr = Math.round(window.devicePixelRatio || 1)\n\n  // widget styling constants.\n  const WIDTH = 160\n  const TEXT_SIZE = 10\n  const TEXT_START = [7, 37]\n  const TEXT_SPACING = 6\n  const HEADER_SIZE = 15\n  const BOTTOM_SPACING = 20\n  const HEADER_POS = [3, 3]\n  const BG = '#000'\n  const FG = '#ccc'\n  const HEIGHT = (drawCalls.length + 17) * TEXT_SIZE + (drawCalls.length - 1) * TEXT_SPACING + TEXT_START[1] + BOTTOM_SPACING\n\n  // we draw the widget on a canvas.\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')\n  if (!context) {\n    return nullOp\n  }\n\n  // set canvas size\n  canvas.width = WIDTH * pr\n  canvas.height = HEIGHT * pr\n  canvas.style.cssText = 'width:' + WIDTH + 'px;height:' + HEIGHT + 'px'\n\n  // draw background.\n  context.fillStyle = BG\n  context.fillRect(0, 0, WIDTH * pr, HEIGHT * pr)\n\n  // draw header.\n  context.font = 'bold ' + HEADER_SIZE * pr + 'px Helvetica,Arial,sans-serif'\n  context.textBaseline = 'top'\n  context.fillStyle = FG\n  context.fillText('Stats', HEADER_POS[0] * pr, HEADER_POS[1] * pr)\n\n  container.appendChild(canvas)\n  document.body.appendChild(container)\n\n  const round = (v: number) => Math.round(10.0 * v) / 10.0\n\n  return {\n    update: (deltaTime: number): void => {\n      let drawCall\n      totalTime += deltaTime\n      if (totalTime > 1.0) {\n        totalTime = 0\n\n        // make sure that we clear the old text before drawing new text.\n        context.fillStyle = BG\n        context.fillRect(TEXT_START[0] * pr, TEXT_START[1] * pr, (WIDTH - TEXT_START[0]) * pr, (HEIGHT - TEXT_START[1]) * pr)\n\n        context.font = 'bold ' + TEXT_SIZE * pr + 'px Helvetica,Arial,sans-serif'\n        context.fillStyle = FG\n\n        const textCursor = [TEXT_START[0], TEXT_START[1]]\n        const println = (str: string) => {\n          context.fillText(str, textCursor[0] * pr, textCursor[1] * pr)\n          textCursor[1] += TEXT_SIZE + TEXT_SPACING\n        }\n\n        let totalCpu = 0.0\n        let totalGpu = 0.0\n        for (let i = 0; i < drawCalls.length; i++) {\n          drawCall = drawCalls[i]\n          const gpuTime = queryTimerExt() ? round(avgGpuFrameTime[i]) : 'n/a'\n          println(drawCall[1] + ' : ' + round(avgGpuFrameTime[i] + avgCpuFrameTime[i]) + 'ms (' + round(avgCpuFrameTime[i]) + ' | ' + gpuTime + ')')\n          totalCpu += avgCpuFrameTime[i]\n          totalGpu += avgGpuFrameTime[i]\n        }\n        println('total : ' + round(totalGpu + totalCpu) + 'ms (' + round(totalCpu) + ' | ' + round(totalGpu) + ')')\n        println('')\n        const bufferSize = regl.stats.getTotalBufferSize ? getReadableFileSizeString(regl.stats.getTotalBufferSize()) : 'n/a'\n        println('buffers : ' + regl.stats.bufferCount + ` @ ${bufferSize}`)\n        println('textures : ' + regl.stats.textureCount)\n        const textSize = regl.stats.getTotalTextureSize ? getReadableFileSizeString(regl.stats.getTotalTextureSize()) : 'n/a'\n        println('cubes : ' + regl.stats.cubeCount + ` @ ${textSize}`)\n        println('elements : ' + regl.stats.elementsCount)\n        println('framebuffers : ' + regl.stats.framebufferCount)\n        println('shaders : ' + regl.stats.shaderCount)\n        if (regl.stats.getTotalRenderbufferSize) {\n          println('renderBuffers : ' + getReadableFileSizeString(regl.stats.getTotalRenderbufferSize()))\n        }\n        if (regl.stats.getMaxUniformsCount) {\n          println('max uniforms : ' + regl.stats.getMaxUniformsCount())\n        }\n        if (regl.stats.getMaxAttributesCount) {\n          println('max attributes : ' + regl.stats.getMaxAttributesCount())\n        }\n      }\n\n      frameTimeCount++\n      // make sure to update the previous gpuTime, and to compute the average.\n      for (i = 0; i < drawCalls.length; i++) {\n        drawCall = drawCalls[i]\n\n        let gpuFrameTime = drawCall[0].stats.gpuTime - prevGpuTimes[i]\n        let cpuFrameTime = drawCall[0].stats.cpuTime - prevCpuTimes[i]\n        totalGpuFrameTime[i] += gpuFrameTime\n        totalCpuFrameTime[i] += cpuFrameTime\n\n        if (frameTimeCount === N) {\n          avgGpuFrameTime[i] = totalGpuFrameTime[i] / N\n          totalGpuFrameTime[i] = 0.0\n          avgCpuFrameTime[i] = totalCpuFrameTime[i] / N\n          totalCpuFrameTime[i] = 0.0\n        }\n\n        prevGpuTimes[i] = drawCall[0].stats.gpuTime\n        prevCpuTimes[i] = drawCall[0].stats.cpuTime\n      }\n\n      // reset avg calculation.\n      if (frameTimeCount === N) {\n        frameTimeCount = 0\n      }\n    },\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
