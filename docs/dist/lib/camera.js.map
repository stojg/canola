{
  "version": 3,
  "sources": ["/Users/stojg/Sites/canola/src/lib/camera.ts"],
  "sourcesContent": ["import type REGL from 'regl'\nimport { glMatrix, mat4, quat, vec3 } from 'gl-matrix'\nimport { Transform } from './transform'\nimport type { FPSControls } from './controls'\n\ninterface CameraProps {\n  up?: REGL.Vec3\n  transform?: Transform\n  position?: vec3\n  rotation?: quat\n}\n\nexport function createCamera(regl: REGL.Regl, controls: FPSControls, props: CameraProps) {\n  const cameraState = {\n    transform:\n      props.transform ||\n      new Transform({\n        position: props.position,\n        rotation: props.rotation,\n      }),\n    // copied on update from the transform\n    yawChange: 0,\n    pitchChange: 0,\n    pointerLocked: false,\n    up: new Float32Array(props.up || [0, 1, 0]),\n    projection: mat4.identity(new Float32Array(16)),\n    view: mat4.identity(new Float32Array(16)),\n    camPos: props.position,\n  }\n\n  const uniforms = ['projection', 'view', 'camPos']\n\n  function look() {\n    const ptrSensitivity = 0.005\n    const ptr = controls.pointerMovement()\n    cameraState.yawChange = lerp(cameraState.yawChange, ptr[0] * ptrSensitivity, 0.5)\n    cameraState.pitchChange = lerp(cameraState.pitchChange, ptr[1] * ptrSensitivity, 0.5)\n    cameraState.transform.rotateXY(-cameraState.yawChange, -cameraState.pitchChange)\n  }\n\n  function move() {\n    let move = vec3.create()\n    let tmp = vec3.create()\n    if (controls.keyPressed('w')) {\n      vec3.transformQuat(tmp, [0, 0, -1], cameraState.transform.rotation)\n      vec3.add(move, move, tmp)\n    }\n    if (controls.keyPressed('s')) {\n      vec3.transformQuat(tmp, [0, 0, 1], cameraState.transform.rotation)\n      vec3.add(move, move, tmp)\n    }\n    if (controls.keyPressed('a')) {\n      vec3.transformQuat(tmp, [-1, 0, 0], cameraState.transform.rotation)\n      vec3.add(move, move, tmp)\n    }\n    if (controls.keyPressed('d')) {\n      vec3.transformQuat(tmp, [1, 0, 0], cameraState.transform.rotation)\n      vec3.add(move, move, tmp)\n    }\n    const sensitivity = 0.1\n    vec3.scale(move, move, sensitivity)\n    cameraState.transform.addPosition(move)\n  }\n\n  function view() {\n    // conjugate rotation because the world should appear to rotate opposite to the camera's rotation.\n    const rotation: quat = quat.create()\n    mat4.getRotation(rotation, cameraState.transform.transformation)\n    quat.conjugate(rotation, rotation)\n    // similar, the translation is inverted because the world appears to move opposite to the camera's movement.\n    const translation = vec3.create()\n    mat4.getTranslation(translation, cameraState.transform.transformation)\n    vec3.negate(translation, translation)\n    // convert from whatever it is back into mat4\n    const cameraRotation = mat4.create()\n    mat4.fromQuat(cameraRotation, rotation)\n    const cameraTranslation = mat4.create()\n    mat4.fromTranslation(cameraTranslation, translation)\n    // now we can set the view\n    mat4.multiply(cameraState.view, cameraRotation, cameraTranslation)\n  }\n\n  function update() {\n    cameraState.camPos = vec3.clone(cameraState.transform.position)\n    look()\n    move()\n    cameraState.transform.update()\n    view()\n  }\n\n  const injectContext = regl({\n    context: Object.assign({}, cameraState, {\n      projection: (ctx: REGL.DefaultContext) => mat4.perspective(cameraState.projection, glMatrix.toRadian(80), ctx.viewportWidth / ctx.viewportHeight, 0.01, 1000.0),\n      // cameraPosition: (ctx: REGL.DefaultContext) => cameraState.cameraPosition\n    }),\n    uniforms: Object.keys(cameraState).reduce((res: {}, name: string) => {\n      if (uniforms.includes(name)) {\n        // @ts-ignore\n        res[name] = regl.context(name)\n      }\n      return res\n    }, {}),\n  })\n\n  function render(block: any) {\n    update()\n    injectContext(block)\n  }\n  return render\n}\n\nfunction lerp(a: number, b: number, amount: number): number {\n  return a * (1 - amount) + b * amount\n}\n"],
  "mappings": "AACA;AACA;AAUO,6BAAsB;AAC3B,sBAAoB;AAAA,IAClB,WACE,MAAM,aACN,IAAI,UAAU;AAAA,MACZ,UAAU,MAAM;AAAA,MAChB,UAAU,MAAM;AAAA;AAAA,IAGpB,WAAW;AAAA,IACX,aAAa;AAAA,IACb,eAAe;AAAA,IACf,IAAI,IAAI,aAAa,MAAM,MAAM,CAAC,GAAG,GAAG;AAAA,IACxC,YAAY,KAAK,SAAS,IAAI,aAAa;AAAA,IAC3C,MAAM,KAAK,SAAS,IAAI,aAAa;AAAA,IACrC,QAAQ,MAAM;AAAA;AAGhB,mBAAiB,CAAC,cAAc,QAAQ;AAExC;AACE,2BAAuB;AACvB,gBAAY,SAAS;AACrB,gBAAY,YAAY,KAAK,YAAY,WAAW,IAAI,KAAK,gBAAgB;AAC7E,gBAAY,cAAc,KAAK,YAAY,aAAa,IAAI,KAAK,gBAAgB;AACjF,gBAAY,UAAU,SAAS,CAAC,YAAY,WAAW,CAAC,YAAY;AAAA;AAGtE;AACE,gBAAW,KAAK;AAChB,cAAU,KAAK;AACf,QAAI,SAAS,WAAW;AACtB,WAAK,cAAc,KAAK,CAAC,GAAG,GAAG,KAAK,YAAY,UAAU;AAC1D,WAAK,IAAI,OAAM,OAAM;AAAA;AAEvB,QAAI,SAAS,WAAW;AACtB,WAAK,cAAc,KAAK,CAAC,GAAG,GAAG,IAAI,YAAY,UAAU;AACzD,WAAK,IAAI,OAAM,OAAM;AAAA;AAEvB,QAAI,SAAS,WAAW;AACtB,WAAK,cAAc,KAAK,CAAC,IAAI,GAAG,IAAI,YAAY,UAAU;AAC1D,WAAK,IAAI,OAAM,OAAM;AAAA;AAEvB,QAAI,SAAS,WAAW;AACtB,WAAK,cAAc,KAAK,CAAC,GAAG,GAAG,IAAI,YAAY,UAAU;AACzD,WAAK,IAAI,OAAM,OAAM;AAAA;AAEvB,wBAAoB;AACpB,SAAK,MAAM,OAAM,OAAM;AACvB,gBAAY,UAAU,YAAY;AAAA;AAGpC;AAEE,qBAAuB,KAAK;AAC5B,SAAK,YAAY,UAAU,YAAY,UAAU;AACjD,SAAK,UAAU,UAAU;AAEzB,wBAAoB,KAAK;AACzB,SAAK,eAAe,aAAa,YAAY,UAAU;AACvD,SAAK,OAAO,aAAa;AAEzB,2BAAuB,KAAK;AAC5B,SAAK,SAAS,gBAAgB;AAC9B,8BAA0B,KAAK;AAC/B,SAAK,gBAAgB,mBAAmB;AAExC,SAAK,SAAS,YAAY,MAAM,gBAAgB;AAAA;AAGlD;AACE,gBAAY,SAAS,KAAK,MAAM,YAAY,UAAU;AACtD;AACA;AACA,gBAAY,UAAU;AACtB;AAAA;AAGF,wBAAsB,KAAK;AAAA,IACzB,SAAS,OAAO,OAAO,IAAI,aAAa;AAAA,MACtC,YAAY,SAA8B,KAAK,YAAY,YAAY,YAAY,SAAS,SAAS,KAAK,IAAI,gBAAgB,IAAI,gBAAgB,MAAM;AAAA;AAAA,IAG1J,UAAU,OAAO,KAAK,aAAa,OAAO;AACxC,UAAI,SAAS,SAAS;AAEpB,YAAI,QAAQ,KAAK,QAAQ;AAAA;AAE3B,aAAO;AAAA,OACN;AAAA;AAGL;AACE;AACA,kBAAc;AAAA;AAEhB,SAAO;AAAA;AAGT;AACE,SAAO,IAAK,KAAI,UAAU,IAAI;AAAA;",
  "names": []
}
